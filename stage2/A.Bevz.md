**XML**

Структура *XML* повністю побудована на тегах:
```
<тег>дані</тег>
```
і деревах з цих тегів:
```
<тег_Категорії_1>
    <тег_Характеристики_1>Дані_1</тег_Характеристики_1>
    <тег_Характеристики_2>Дані_2</тег_Характеристики_2>
</тег_Категорії_1>
```
Модуль для обробки *XML* у *Python* складається з наступних субмодулів:
- xml.etree.ElementTree
- xml.dom
- xml.dom.minidom
- xml.dom.pulldom
- xml.sax
- xml.parsers.expat

Оскільки *XML* має структуру дерева, найважливішим субмодулем є *xml.etree.ElementTree*.
Він дозволяє перетворювати файл *.xml* або стрічку у об'єкт *Python*.
Приклад використання:
```
import xml.etree.ElementTree as ETree
xml_tree = ETree.parse('example.xml')
root = xml_tree.getroot()
```
Метод *getroot()* створеного функцією *parse()* об'єкту повертає об'єкт, який є безпосередньою реалізацією дерева.
Він сам має атрибути *tag* (назва тегу) і *attrib* (атрибути тегу).
При цьому, якщо у тегу є дочірні теги, вони є такими самими об'єктами, і до них можна доступитися через *__getitem__()* або *__iter__()*, наприклад:
```
for child in root:
    print(child.tag, child.attrib)
...
print(root[0][1])
...
```
Крім цього, клас *XMLParser* дозволяє зчитувати документ на ходу, а не цілий файл відразу (наприклад, при його завантаженні чи динамічному оновленні).

Окрім читання, субмодуль *xml.etree.ElementTree* має ще й функцію модифікації *XML*.
Це можна робити двома способами - змінювати вже записані дані простим присвоєнням, наприклад
```
root[0][1].name = 'Gordon'
```
або створювати чи видаляти вітки командами *set()* і *remove()*:
```
root[0][1].set('name', 'Gordon')
root[0][1].remove('headcrab')
```
